-- Two-thread Treiber stack over 2 nodes; free1/free2 work as a free-pool stack emulating (EMM)
-- with an explicit chosen mechanic for selecting which free node to push

MODULE main
VAR
  -- Shared stack top: 0=NULL, 1=NODE1, 2=NODE2
  top         : 0..2;

  -- Free-pool flags: TRUE = node free; FALSE = allocated
  free1       : boolean;
  free2       : boolean;

  -- Each node's next pointer (valid if allocated)
  next1       : 0..2;
  next2       : 0..2;

  -- Node payloads (1 or 2)
  val1        : 1..2;    -- NODE1 payload, initially 1; on reallocate becomes 2
  val2        : 1..2;    -- NODE2 payload, initially 2; on reallocate becomes 1

  --delay

  -- Thread 1 control & locals (with two extra pop steps)
  p1.pc       : 0..7;
  p1.op      : 0..2;    -- operation type {PUSH=0, POP=1, NONE=2}
  p1.old_top  : 0..2;-- Cas variables
  p1.old_next : 0..2;
  p1.ret      : 0..2;
  p1.ret_push : boolean; -- return value for T1 push operation (TRUE=success, FALSE=failure)
  p1.chosen   : 0..2;    -- which node T1 will allocate on its next push (0=none,1 or 2)

  -- Thread 2 control & locals
  p2.pc       : 0..6;    -- 0-start_pop,1-pop,2-return,3-start_push,4-push,5-return_push(done)
  p2.old_top  : 0..2;
  p2.old_next : 0..2;
  p2.ret      : 0..2;    -- return value for T2 pop operation
  p2.ret_push : boolean; -- return value for T2 push operation (TRUE=success, FALSE=failure)
  p2.chosen   : 0..2;    -- which node T2 will allocate on its next push (0=none,1 or 2)

ASSIGN
  -- Initial state: stack = [1->2->NULL]
  init(top)        := 1;
  init(next1)      := 2;
  init(next2)      := 0;
  init(free1)      := FALSE;
  init(free2)      := FALSE;
  init(val1)       := 1;
  init(val2)       := 2;

  init(p1.pc)      := 0;
  init(p1.op)      := 2; -- NONE
  init(p1.old_top) := 0;
  init(p1.old_next):= 0;
  init(p1.ret)     := 0;
  init(p1.ret_push):= FALSE;
  init(p1.chosen)  := 0;

  init(p2.pc)      := 0;
  init(p2.old_top) := 0;
  init(p2.old_next):= 0;
  init(p2.ret)     := 0;
  init(p2.ret_push):= FALSE;
  init(p2.chosen)  := 0;

  -- Update val1 on T2's push CAS; and val2 on T1's push CAS
  next(val1) := case
    p2.pc = 4 & p2.chosen = 1 : {1, 2};
    TRUE                      : val1;
  esac;
  next(val2) := case
    p1.pc = 6 & p1.chosen = 2 : {1, 2};
    TRUE                      : val2;
  esac;

  -- Update shared top
  next(top) := case
    p1.pc = 2 & top = p1.old_top : p1.old_next;
    p1.pc = 2                    : top;
    p2.pc = 1 & top = p2.old_top : p2.old_next;
    p2.pc = 1                    : top;
    p1.pc = 6 & p1.chosen != 0   : p1.chosen;
    p2.pc = 4 & p2.chosen != 0   : p2.chosen;
    TRUE                         : top;
  esac;

  -- Update next1
  next(next1) := case
    p1.pc = 2 & p1.old_top = 1 & top = p1.old_top : 0;
    p2.pc = 1 & p2.old_top = 1 & top = p2.old_top : 0;
    p1.pc = 5 & p1.chosen = 1                     : top;
    p2.pc = 3 & free1                             : top;
    TRUE                                          : next1;
  esac;

  -- Update next2
  next(next2) := case
    p1.pc = 2 & p1.old_top = 2 & top = p1.old_top : 0;
    p2.pc = 1 & p2.old_top = 2 & top = p2.old_top : 0;
    p1.pc = 5 & p1.chosen = 2                     : top;
    p2.pc = 3 & free2                             : top;
    TRUE                                          : next2;
  esac;

  -- Update free1
  next(free1) := case
    p1.pc = 2 & p1.old_top = 1 & top = p1.old_top : TRUE;
    p2.pc = 1 & p2.old_top = 1 & top = p2.old_top : TRUE;
    p1.pc = 6 & p1.chosen = 1                     : FALSE;
    p2.pc = 4 & p2.chosen = 1                     : FALSE;
    TRUE                                          : free1;
  esac;

  -- Update free2
  next(free2) := case
    p1.pc = 2 & p1.old_top = 2 & top = p1.old_top : TRUE;
    p2.pc = 1 & p2.old_top = 2 & top = p2.old_top : TRUE;
    p1.pc = 6 & p1.chosen = 2                     : FALSE;
    p2.pc = 4 & p2.chosen = 2                     : FALSE;
    TRUE                                          : free2;
  esac;

  -- Thread 1 control flow (pop goes through two extra steps before done; push unchanged)
  next(p1.pc) := case
    p1.pc = 0 : {1, 5};
    p1.pc = 1 : {1, 2};  
    p1.pc = 2 : 3;       
    p1.pc = 3 : 4;
    (p1.pc = 4) & (p2.pc = 4) : 4;
    p1.pc = 4 & p2.pc != 4 : 7;       
    p1.pc = 5 & (p2.pc != 5) : 5;
    p1.pc = 5 & (p2.pc = 5) : 6;     
    p1.pc = 6 : 7;      
    TRUE      : 0;       
  esac;

  next(p1.op) := case
    p1.pc = 1 : 1; -- choose PUSH or POP
    p1.pc = 5 : 0; -- choose PUSH or POP
    p1.pc = 7 : 2; -- done
    TRUE      : p1.op;
  esac;

  -- Snapshot for pop (T1)
  next(p1.old_top) := case
    p1.pc = 1                   : top;
    TRUE                        : p1.old_top;
  esac;
  next(p1.old_next) := case
    p1.pc = 1 & top = 1 : next1;
    p1.pc = 1 & top = 2 : next2;
    TRUE                : p1.old_next;
  esac;

  -- Record return (T1) after the two extra pop steps
  next(p1.ret) := case
    p1.pc = 4 & top = p1.old_top & free1  : val2;
    p1.pc = 4 & top = p1.old_top & free2  : 0;
    p1.pc = 4 & top = p1.old_top & !free1 : val1;
    p1.pc = 4 & top != p1.old_top         : 0;
    TRUE                                  : p1.ret;
  esac;

  -- Record return (T1) push operation
  next(p1.ret_push) := case
    p1.pc = 6 & p1.chosen != 0 : TRUE;   -- push succeeds if node was chosen
    p1.pc = 6 & p1.chosen = 0  : FALSE;  -- push fails if no node available
    TRUE                       : p1.ret_push;
  esac;

  -- Choose which node T1 will push at push_load
  next(p1.chosen) := case
    p1.pc = 5 & free2 : 2;
    p1.pc = 5 & free1 : 1;
    TRUE      : p1.chosen;
  esac;

  -- Thread 2 control flow (unchanged)
  next(p2.pc) := case
    p2.pc = 0 : 1;
    p2.pc = 1 : 2;
    p2.pc = 2 : 3;
    p2.pc = 3 : 4;
    p2.pc = 4 : 5;
    TRUE      : 0;
  esac;

  -- Snapshot for pop (T2)
  next(p2.old_top) := case
    p2.pc = 0 : top;
    TRUE      : p2.old_top;
  esac;
  next(p2.old_next) := case
    p2.pc = 0 & top = 1 : next1;
    p2.pc = 0 & top = 2 : next2;
    TRUE : p2.old_next;
  esac;

  -- Record return (T2) after pop cas
  next(p2.ret) := case
    p2.pc = 1 & top = p2.old_top & p2.old_top = 1 & !free1 : val1;
    p2.pc = 1 & top = p2.old_top & p2.old_top = 2 & !free2 : val2;
    p2.pc = 1 & top = p2.old_top & p2.old_top = 1 & free1  : 0;
    p2.pc = 1 & top = p2.old_top & p2.old_top = 2 & free2  : 0;
    p2.pc = 1 & top != p2.old_top                          : 0;
    TRUE                                                   : p2.ret;
  esac;

  -- Record return (T2) push operation
  next(p2.ret_push) := case
    p2.pc = 4 & p2.chosen != 0 : TRUE;   -- push succeeds if node was chosen
    p2.pc = 4 & p2.chosen = 0  : FALSE;  -- push fails if no node available
    TRUE                       : p2.ret_push;
  esac;

  -- Choose which node T2 will push at push_load
  next(p2.chosen) := case
    p2.pc = 3 & free2 : 2;
    p2.pc = 3 & free1 : 1;
    TRUE              : p2.chosen;
  esac;

DEFINE
  -- Thread 1 operation predicates
  p1.push_invoked := (p1.pc = 5) | (p1.pc = 6);  -- push_load or push_cas
  p1.pop_invoked  := (p1.pc = 1) | (p1.pc = 2) | (p1.pc = 3) | (p1.pc = 4);  -- pop_load, pop_cas, pop_extra1, pop_extra2

  -- Thread 2 operation predicates  
  p2.push_invoked := (p2.pc = 3) | (p2.pc = 4);  -- push_load or push_cas
  p2.pop_invoked  := (p2.pc = 0) | (p2.pc = 1);  -- pop_load or pop_cas

  -- Combined operation predicates
  invoked_push := (p1.push_invoked | p2.push_invoked);
  invoked_pop  := (p1.pop_invoked | p2.pop_invoked);

  -- Return predicates
  returning_push := (p1.pc = 7 & p1.op = 0) | (p2.pc = 5);
  returning_pop  := (p1.pc = 7 & p1.op = 1) | (p2.pc = 2);

  -- Success return predicates
  push_return := (p1.ret_push) | (p2.ret_push);
  pop_return  := (p1.ret != 0) | (p2.ret != 0);
