-- // SNARK structure (with some accelerations):
-- // 0   ------- STAND BY: could go to line:1/ line:10/ line:19
-- // 	  popRight() starts:
-- // 1   - getRightHat as rh
-- // 2		- getLeftHat as lh
-- // 3		- if (rh is self-pointing) return assign popRight_fAIL
-- // 4 	- else if (rh equals lh)
-- // 5			DCAS (RightHat, LeftHat, rh, lh, Dummy, Dummy)
-- // 6			assign pop_result as rh->V
-- // 7		- else  assign rhl as rh->L
-- // 8				DCAS (RightHat, rh->L, rh, rhL, rhL, rh)
-- // 9				assign popRight_result as rh->V, assign rh->R as DUMMY
-- //     pushRight() starts:
-- // 10    - assing nd as Y --> if null, return pushRight_fAIL
-- // 11		- assign nd->R as Dummy,assign nd-> V as something (zero for now)
-- // 12		- assign rh as RightHat, assign rhR as rh->R
-- // 13		if (rh == rhR), assign nd -> L = Dummy, assign lh = LeftHat
-- // 14			 DCAS (RightHat, LeftHat, rh, lh, nd, nd)
-- // 15			 return pushRight_SUCCESS
-- // 16		else   assign nd->L as rh
-- // 17			   DCAS(RightHat, rh->R, rh, rhR, nd, nd)
-- // 18			   return pushRight_SUCCESS
-- //  	  popLeft() starts:
-- // 19		- assign lh as LeftHat, assign rh as RightHat
-- // 20		- if (lh is self-pointing), return assign popLeft_fAIL
-- // 21		- else if (lh == rh)
-- // 22				DCAS (LeftHat, RightHat, lh, rh, Dummy, Dummy)
-- // 23				assign popLeft_result as lh -> V
-- // 24		- else  assign lhR as lh->R
-- // 25				DCAS (LeftHat, lh->R, lh, lhR, lfR, lh)
-- // 26				assign popLeft_result as lh->V, assign lh_L as DDUMMY

MODULE main
VAR

	-- ##############################################################################
	RightHat: 0..2; 
	-- could be DUNNY, x, y, or z
	LeftHat: 0..2; 
	-- could be DUMMY, x, y, or z

	AllNodes[0][0]: 0..2;
	AllNodes[0][1]: 0..2;
	AllNodes[1][0]: 0..2;
	AllNodes[1][1]: 0..2;
	AllNodes[2][0]: 0..2;
	AllNodes[2][1]: 0..2;

	First_ProcID: 1..2;
	Second_ProcID: 1..2;

	-- ##############################################################################


	-- ##############################################################################
	-- Proc 1 VAR
	proc1.line: 0..9;
	-- ##############################################################################

	-- ##############################################################################
	-- Proc 2 VAR
	proc2.line: 0..9;
	-- ##############################################################################


	-- ##############################################################################
	-- Queue Var 
	newnode : 0..2; 
	-- for push right
	popRightfAIL: boolean;
	temp_popRightfAIL:  boolean;

	BOTH_MODIFYING : boolean;

	proc1.popRightSTART : boolean;
	proc1.popRightEND : boolean;
	proc1.pushRightSTART : boolean;
	proc1.pushRightEND : boolean;
	proc1.popLeftSTART : boolean;
	proc1.popLeftEND : boolean;
	proc1.modifying : boolean;

	proc2.popRightSTART : boolean;
	proc2.popRightEND : boolean;
	proc2.pushRightSTART : boolean;
	proc2.pushRightEND : boolean;
	proc2.popLeftSTART : boolean;
	proc2.popLeftEND : boolean;
	proc2.modifying : boolean;


	-- ##############################################################################

	ASSIGN
		init(proc2.popRightSTART) := FALSE;
		next(proc2.popRightSTART) :=
			case
				(proc2.line=1 | proc2.line=2 | proc2.line=3) : TRUE;
				TRUE : proc2.popRightSTART;
			esac;

		init(proc2.popRightEND) := FALSE;
		next(proc2.popRightEND) :=
			case
				(proc2.line=0) : TRUE;
				TRUE : proc2.popRightEND;
			esac;

		init(proc2.pushRightSTART) := FALSE;
		next(proc2.pushRightSTART) :=
			case
				(proc2.line=4 | proc2.line=5) : TRUE;
				TRUE : proc2.pushRightSTART;
			esac;

		init(proc2.pushRightEND) := FALSE;
		next(proc2.pushRightEND) :=
			case
				(proc2.line=0) : TRUE;
				TRUE : proc2.pushRightEND;
			esac;

		init(proc2.popLeftSTART) := FALSE;
		next(proc2.popLeftSTART) :=
			case
				(proc2.line=7 | proc2.line=8) : TRUE;
				TRUE : proc2.popLeftSTART;
			esac;

		init(proc2.popLeftEND) := FALSE;
		next(proc2.popLeftEND) :=
			case
				(proc2.line=0) : TRUE;
				TRUE : proc2.popLeftEND;
			esac;

		init(proc2.modifying) := FALSE;
		next(proc2.modifying) :=
			case
				(proc2.line=1 | proc2.line=4 | proc2.line=7) : TRUE;
				TRUE : proc2.modifying;
			esac;


		init(proc1.popRightSTART) := FALSE;
		next(proc1.popRightSTART) :=
			case
				(proc1.line=1 | proc1.line=2 | proc1.line=3) : TRUE;
				TRUE : proc1.popRightSTART;
			esac;

		init(proc1.popRightEND) := FALSE;
		next(proc1.popRightEND) :=
			case
				(proc1.line=0) : TRUE;
				TRUE : proc1.popRightEND;
			esac;

		init(proc1.pushRightSTART) := FALSE;
		next(proc1.pushRightSTART) :=
			case
				(proc1.line=4 | proc1.line=5) : TRUE;
				TRUE : proc1.pushRightSTART;
			esac;

		init(proc1.pushRightEND) := FALSE;
		next(proc1.pushRightEND) :=
			case
				(proc1.line=0) : TRUE;
				TRUE : proc1.pushRightEND;
			esac;

		init(proc1.popLeftSTART) := FALSE;
		next(proc1.popLeftSTART) :=
			case
				(proc1.line=7 | proc1.line=8) : TRUE;
				TRUE : proc1.popLeftSTART;
			esac;

		init(proc1.popLeftEND) := FALSE;
		next(proc1.popLeftEND) :=
			case
				(proc1.line=0) : TRUE;
				TRUE : proc1.popLeftEND;
			esac;

		init(proc1.modifying) := FALSE;
		next(proc1.modifying) :=
			case
				(proc1.line=1 | proc1.line=4 | proc1.line=7) : TRUE;
				TRUE : proc1.modifying;
			esac;

		init(BOTH_MODIFYING):= FALSE;
		next(BOTH_MODIFYING):=
			case
				(proc1.modifying & proc2.modifying) : TRUE;
				TRUE: BOTH_MODIFYING;
			esac;
		-- ##############################################################################
		-- Global ASSIGN
		init(First_ProcID) 	:= 1;
		init(Second_ProcID) := 2;
		next(First_ProcID)	:= First_ProcID;
		next(Second_ProcID)	:= Second_ProcID;

		init(RightHat) := 1;
		init(LeftHat) := 1;
		init(AllNodes[0][0]) := 0;
		init(AllNodes[0][1]) := 0; -- DUMMY
		init(AllNodes[1][0]) := 0;
		init(AllNodes[1][1]) := 0; -- X
		init(AllNodes[2][0]) := 2;
		init(AllNodes[2][1]) := 2; -- Y
		-- ##############################################################################


		-- ##############################################################################
		-- Proc 1 ASSIGN
		init(proc1.line) := 0;
		next(proc1.line) :=
			case
				(proc1.line=0 & First_ProcID=1)  : {1,4,7}; 		-- STAND BY: could go to line:1/ line:4/ line:7
				(proc1.line=0 & First_ProcID=2)  : {1,4,7}; 		-- STAND BY: could go to line:1/ line:4/ line:7
				(proc1.line=1)  : {2}; -- popRight() starts, changing nodes
				(proc1.line=2 & LeftHat=1 & RightHat=1)  : {2,3}; -- wait
				(proc1.line=2 & LeftHat=1 & RightHat=2)  : {2,3}; -- wait
				(proc1.line=3)  : {0}; -- popRight() Return, End
				(proc1.line=4)  : {5}; -- pushRight() starts, changing nodes
				(proc1.line=5) 	: {5,0}; -- wait
				(proc1.line=7)  : {8}; -- popLeftt() starts, changing nodes
				(proc1.line=8 & LeftHat=1 & RightHat=1) : {8,0};
				(proc1.line=8 & LeftHat=2 & RightHat=2) : {8,0};
				(proc1.line=8 & LeftHat=1 & RightHat=2) : {8,0};
				TRUE: proc1.line; -- default case
			esac;
		-- ##############################################################################

		-- ##############################################################################
		-- Proc 2 ASSIGN
		init(proc2.line) := 0;
		next(proc2.line) :=
			case
				(proc2.line=0 & Second_ProcID=1)  : {1,4,7}; 		-- STAND BY: could go to line:1/ line:4/ line:7
				(proc2.line=0 & Second_ProcID=2)  : {1,4,7}; 		-- STAND BY: could go to line:1/ line:4/ line:7
				(proc2.line=1)  : {2}; -- popRight() starts, changing nodes
				(proc2.line=2 & LeftHat=1 & RightHat=1)  : {2,3}; -- wait
				(proc2.line=2 & LeftHat=1 & RightHat=2)  : {2,3}; -- wait
				(proc2.line=3)  : {0}; -- popRight() Return, End
				(proc2.line=4)  : {5}; -- pushRight() starts, changing nodes
				(proc2.line=5) 	: {5,0}; -- wait
				(proc2.line=7)  : {8}; -- popLeftt() starts, changing nodes
				(proc2.line=8 & LeftHat=1 & RightHat=1) : {8,0};
				(proc2.line=8 & LeftHat=2 & RightHat=2) : {8,0};
				(proc2.line=8 & LeftHat=1 & RightHat=2) : {8,0};
				TRUE: proc2.line; -- default case
			esac;
		-- ##############################################################################



		-- ##############################################################################
		-- Queue ASSIGN

		init(newnode) := 2;
		next(newnode) := newnode;

		-- for delaying return
		init(temp_popRightfAIL) := FALSE;
		next(temp_popRightfAIL) :=
			case
				((proc1.line=1) & (RightHat = 0)) : TRUE;
				((proc2.line=1) & (RightHat = 0)) : TRUE;
				TRUE: temp_popRightfAIL;
			esac;


		-- to cehck, use GlobalQueue-popRightfAIL[tid]
		init(popRightfAIL) := FALSE;
		next(popRightfAIL) :=
			case
				((proc1.line=3) & (temp_popRightfAIL)) : TRUE;
				((proc2.line=3) & (temp_popRightfAIL)) : TRUE;
				TRUE: popRightfAIL;
			esac;

		next(RightHat) :=
			case
				BOTH_MODIFYING : RightHat;
				-- popRight
				((proc1.line=1) & (RightHat = 2)) : 1;
				((proc1.line=1) & (RightHat = 1)) : 0;
				-- pushRight
				(proc1.line=4) : 2;
				-- popLeft
				((proc1.line=7) & (RightHat = 1)) : 0;
				((proc1.line=7) & (RightHat = 2)) : 1;

				-- popRight
				((proc2.line=1) & (RightHat = 2)) : 1;
				((proc2.line=1) & (RightHat = 1)) : 0;
				-- pushRight
				(proc2.line=4) : 2;
				-- popLeft
				((proc2.line=7) & (RightHat = 1)) : 0;
				((proc2.line=7) & (RightHat = 2)) : 1;
				TRUE: RightHat;
			esac;

		next(LeftHat) :=
			case
				BOTH_MODIFYING : LeftHat;
				-- popRight
				((proc1.line=1) & (LeftHat = 1)) : 0;
				-- pushRight
				-- popLeft
				((proc1.line=7) & (RightHat = 1)) : 2;
				-- popRight
				((proc2.line=1) & (LeftHat = 1)) : 0;
				-- pushRight
				-- popLeft
				((proc2.line=7) & (RightHat = 1)) : 2;
				TRUE: LeftHat;
			esac;

			--- GLOBAL variables for double-ended queue
			next(AllNodes[0][0]) := AllNodes[0][0]; -- DUMMY
			next(AllNodes[0][1]) := AllNodes[0][1]; -- DUMMY

			-- X -> L
			next(AllNodes[1][0]) :=
				case
					TRUE: AllNodes[1][0];
				esac;

			-- X -> R
			next(AllNodes[1][1]) :=
				case
					BOTH_MODIFYING : AllNodes[1][1];
					((proc1.line=1) & (RightHat=1)): 1;
					((proc1.line=4) & (RightHat=1)): 2; -- push y
					((proc1.line=7) & (LeftHat=1)): 1;

					((proc2.line=1) & (RightHat=1)): 1;
					((proc2.line=4) & (RightHat=1)): 2; -- push y
					((proc2.line=7) & (LeftHat=1)): 1;
					TRUE: AllNodes[1][1];
				esac;

			-- Y -> L
			next(AllNodes[2][0]) :=
				case
					BOTH_MODIFYING : AllNodes[2][0];
					((proc1.line=1) & (RightHat=2)): 2;
					((proc1.line=4) & (RightHat=1)): 1;
					((proc1.line=7) & (LeftHat=1)) : 0;
					((proc2.line=1) & (RightHat=2)): 2;
					((proc2.line=4) & (RightHat=1)): 1;
					((proc2.line=7) & (LeftHat=1)) : 0;
					TRUE: AllNodes[2][0];
				esac;

			-- Y -> R
			next(AllNodes[2][1]) :=
				case
					BOTH_MODIFYING : AllNodes[2][1];
					((proc1.line=4) & (RightHat=1)): 0;
					((proc2.line=4) & (RightHat=1)): 0;
					TRUE: AllNodes[2][1];
				esac;
